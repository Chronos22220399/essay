# C++ 引用
在 C++98/03 中增加了引用的语法，但是在 C++11 之前，一直只有左值引用，而没有右值引用，究其原因是因为引用实质上是对指针的包装，而左值有地址，右值没地址，而在一些情景下我们产生了两个需求：
1. 深拷贝会造成额外的时间开销和空间开销，因为深拷贝会创建一个新的地址空间给新的变量存放数据
2. 需要实现完美转发，所谓完美转发就是在模板函数中的参数作为其内部调用的函数的参数时，所调用的函数的参数的类型和左、右值特性必须完全相同

于是就有了右值引用。
> 左值就是有地址的变量，而右值就是我们临时创建的没有地址的变量

## 右值引用
为什么要有右值引用呢？因为我们有时可能会需要对右值进行更改，此外，右值引用可以避免不必要的深拷贝，用以减小消耗。

### 右值引用的语法
右值引用的语法与左值引用的语法类似，这种设计是为了让我们感到熟悉。

1. 左值引用：`int &a = b;`
2. 右值引用：`int &&a = 10;`

```CPP
int func(){
    return 10;
}
int main(){
    int &&b = func();
    cout << b << endl;
    return 0;
}
```
在这段代码中，若将 `int &&b = func()`中的 && 去掉，则程序会执行一次构造函数，两次拷贝构造函数（一次是函数利用 a 通过拷贝构造函数创建一个临时变量，一次是对 b 使用拷贝构造函数），而不去掉 && 就只会使用一次构造函数，一次拷贝构造函数

在 CPP 中，编译器会优先在将左值转换为右值时，会优先考虑移动构造函数，若不存在移动构造函数，才会使用复制构造函数，究其原因是因为移动构造函数可以最大限度的降低消耗

## move 函数
move 函数用于将左值转换为右值，但是该右值中若含有指针，且该右值有被移动构造函数所使用的话，该右值的来源 --- 左值里的指针将会指向空指针。
> 这也就是说，move 转换后的右值实质上和原本的左值用的同一块内存空间。

## 引用限定符
引用限定符用于修饰函数，让特定类型（左值或右值）使用该函数，引用限定符有两种：

1. `&`：左值可用
2. `&&`：右值可用
### 引用限定符可以和 const 结合使用
在同时使用引用限定符和 const 时，const 必须放在引用限定符的前面，引用限定符和 const 搭配时的用法：

1. `const &&`：右值可用
2. `const &`：左、右值均可使用
> 因为 const 函数只有 const 对象才可使用，而 右值对象属于const 对象的子集


## 完美转发
前面提到过完美转发的概念，所谓完美转发就是函数的参数被函数内部调用的函数作为参数使用时，参数的值和属性（左值或右值）都不变
值不变这一点不需要考虑，因为本身是成立的，而属性不变这一点就需要去单独设计了。

### 解决属性不变问题
#### 针对传入的参数进行设计
在 C++98/03 中，我们实现完美转发的方式是将内层被调用的函数进行重载，分别重载对应的左值调用和右值调用，例如：
```CPP
template <typename T>
void func1(T &t){}

template <typename T>
void func2(const T &t){}

// 接收左值参数
template <typename T>
void fun1(T &t){
    func1(t);
}

// 接收右值参数
template <typename T>
void fun2(const T &t){
    func2(t);
}
```
这种方式非常的笨拙，当函数的参数变多时，需要重载的函数个数将呈指数倍增长。

于是 C++11 中对其有了新的改进：

首先，对于模板函数而言，若其参数的类型为右值引用，则函数的参数可以接受左值或右值，这将保证进入函数的参数的类型不变，例如：
```cpp
template <typename T>
void func(T &&t){
    // statement;
}
```
接着，我们还要考虑传入的参数为左值引用和右值引用的情况，面对这种情况， C++11 有一种抵消机制，就是当参数的类型中有三个或四个的 `&` 时，编译器将会以两两为一组的形式消除 `&&`，最后只会剩下 `&` 或 `&&`，说人话就是编译器会将 `T &&&t` 和 `T &&&&t` 分别转换为 `T &t` 和 `T &&t`.

最后，我们需要解决保持传入函数内部的被调用的函数的参数属性不变的问题，对于这个问题，我们无法直接解决，因为当参数进入外部的函数时，无论这个参数原本是左值还是右值，它都将变为左值，所以我们无法直接判断这个参数的属性，因此，C++11 引入了一个函数 `forward<T>(arg)`，这个函数将会判断 arg 的属性。
> 注意，这里的 forward 后面必须跟上 <T>，否则会因为 forward 无法解析类型而报错
例如：
```cpp
template <typename T>
void fun(T &t){}

template <typename T>
void fun1(const T &t){}

template <typename T>
void func(T &&t){
    fun(forward(t));
}
```